#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <unordered_map>
#include <iomanip>
#include <filesystem>

/**
 * @brief Build-time resource packer entry point.
 *
 * Generates a C++ header that embeds input files as raw bytes in a
 * `static const std::unordered_map<std::string, std::vector<unsigned char>>`
 * named `sparkle_resources`, plus two convenience macros.
 *
 * @param argc Argument count.
 * @param argv Argument vector:
 *   - `argv[1]` : Output header path (e.g., `outputHeader.hpp`).
 *   - `argv[2]` : Base directory on disk used to locate files.
 *   - `argv[3+]`: Resource file paths relative to the base directory. These
 *                 relative paths become the map keys in the generated header.
 *
 * @return `0` on success. `1` on usage error, open/read failure, or I/O error.
 *
 * @details
 * For each `argv[i]` with `i >= 3`, the program reads
 * `baseDirectory + "/" + argv[i]` in binary mode and emits its bytes into the
 * generated header as a comma-separated hex list. The generated header contains:
 *
 * - `#pragma once` and required includes.
 * - `sparkle_resources` map:
 *     - Keys: exactly the relative paths passed in `argv[3+]`.
 *     - Values: file contents as `std::vector<unsigned char>`.
 * - Macros:
 *     - `SPARKLE_GET_RESOURCE(key)` → `sparkle_resources.at(key)`
 *     - `SPARKLE_GET_RESOURCE_AS_STRING(key)` → constructs a `std::wstring`
 *       from the byte vector.
 *
 * The generated byte formatting is hex for readability; at compile time they
 * are plain bytes. The tool fails fast if any file cannot be opened or read.
 *
 * @note Requires C++17 or later for `<filesystem>`. File reads use binary mode.
 *
 * @code
 * Usage:
 *   sparkleResourcesConverter <outputHeader.hpp> <baseDirectory> <file1> [file2] ...
 *
 * Example:
 *   sparkleResourcesConverter resources.hpp assets textures/ui.png font/arial.ttf
 *   // Generates resources.hpp with:
 *   //   sparkle_resources["textures/ui.png"]  -> bytes of assets/textures/ui.png
 *   //   sparkle_resources["font/arial.ttf"]   -> bytes of assets/font/arial.ttf
 * @endcode
 */
int main(int argc, char** argv)
{
    const std::string outputHeader = argv[1];
    const std::string baseDirectory = argv[2];

    // Gather resource files
    std::vector<std::string> inputFiles;
    for (int i = 3; i < argc; ++i) {
        inputFiles.push_back(argv[i]);
    }

    // Open the output .hpp
    std::ofstream out(outputHeader);
    if (!out.is_open()) {
        std::cerr << "Error: could not open output file: " << outputHeader << "\n";
        return 1;
    }

    // Write the header prologue
    out << "#pragma once\n";
    out << "#include <string>\n";
    out << "#include <vector>\n";
    out << "#include <unordered_map>\n\n";
    out << "// Auto-generated by sparkleResourcesConverter\n";
    out << "// Contains embedded data for the following files:\n";
    for (auto &f : inputFiles) {
        out << "//   " << f << "\n";
    }
    out << "\n";

    out << "static const std::unordered_map<std::string, std::vector<unsigned char>> sparkle_resources = {\n";

    // For each file, read in binary and embed it
    for (size_t idx = 0; idx < inputFiles.size(); ++idx) {
		const auto& keyName = inputFiles[idx];
        const auto& filePath = baseDirectory + "/" + keyName;

        // Open the file in binary mode
        std::ifstream in(filePath, std::ios::binary | std::ios::ate);
        if (!in) {
            std::cerr << "Error: cannot open " << filePath << "\n";
            return 1;
        }

        std::streamsize fileSize = in.tellg();
        in.seekg(0, std::ios::beg);
        std::vector<unsigned char> buffer(fileSize);

        if (!in.read(reinterpret_cast<char*>(buffer.data()), fileSize)) {
            std::cerr << "Error: failed to read " << filePath << "\n";
            return 1;
        }
        in.close();

        // This relPath.string() is what we'll store as the key.
        out << "    { \"" << keyName << "\", {\n        ";

        // Dump the file data as hex, 16 bytes per line
        for (size_t i = 0; i < buffer.size(); ++i) {
            out << "0x" << std::hex << std::setw(2) << std::setfill('0')
                << static_cast<int>(buffer[i]) << ", ";
            if ((i + 1) % 16 == 0) {
                out << "\n        ";
            }
        }
        out << "\n    } }";
        if (idx + 1 < inputFiles.size()) {
            out << ",";
        }
        out << "\n";
    }

    out << "};\n\n";
    out << "#define SPARKLE_GET_RESOURCE(key) sparkle_resources.at(key)\n";
	out << "#define SPARKLE_GET_RESOURCE_AS_STRING(key) std::wstring(sparkle_resources.at(key).begin(), sparkle_resources.at(key).end())\n";

    out.close();
    return 0;
}
