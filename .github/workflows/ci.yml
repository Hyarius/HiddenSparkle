# Display name for the workflow in the GitHub Actions UI
name: CI

# Event triggers that start this workflow
on:
  # Run the workflow when commits are pushed to main
  push:
    # Restrict push trigger to the main branch
    branches: [ main ]
  # Also run for pull requests targeting any branch
  pull_request:
    # Restrict pull request trigger to every opened pull request
    types: [opened, synchronize, reopened, ready_for_review]

# optional: skip drafts and cancel outdated runs
concurrency:
  group: pr-${{ github.event.pull_request.number || github.ref }}
  cancel-in-progress: true

# Permissions granted to the GITHUB_TOKEN for this workflow
permissions:
  # Allow read access to repository contents required by checkout and analysis
  contents: read
  # Permit publishing documentation to GitHub Pages
  pages: write
  # Enable OIDC token issuance for the deploy-pages action
  id-token: write

# Environment variables available to every job in this workflow
env:
  # Default triplet instructing vcpkg to build for 64-bit Windows
  VCPKG_DEFAULT_TRIPLET: x64-windows
  # Enable vcpkg manifest mode and binary caching for faster installs
  VCPKG_FEATURE_FLAGS: manifests,binarycaching

# Define the set of jobs executed by this workflow
jobs:
  # Job that verifies all tracked C/C++ sources are clang-format compliant
  format-check:
    runs-on: windows-latest
    name: Clang-Format Check

    steps:
      # Checkout repository contents into the runner workspace
      - name: Checkout
        uses: actions/checkout@v4

      # Install LLVM toolchain to obtain clang-format
      - name: Install LLVM (clang-format)
        run: choco install llvm --no-progress --yes
        shell: pwsh

      # Validate formatting without modifying files
      - name: Verify formatting
        shell: pwsh
        run: |
          $patterns = @('*.cpp','*.hpp')
          $roots    = @('includes','srcs')

          $files = @()
          foreach ($root in $roots) {
            foreach ($pat in $patterns) {
              $files += git ls-files -- ":(glob)$root/**/$pat"
            }
          }
          $files = $files | Sort-Object -Unique
          if (-not $files) { Write-Host "No C/C++ sources detected in includes/ or srcs/; skipping clang-format check."; exit 0 }

          $nonCompliant = @()
          foreach ($file in $files) {
            & clang-format --style=file --dry-run --Werror $file 2>$null
            if ($LASTEXITCODE -ne 0) {
              $nonCompliant += $file
              Write-Host "::error file=$file::clang-format reported style violations."
            }
          }

          if ($nonCompliant.Count -gt 0) {
            Write-Host "Non-compliant files ($($nonCompliant.Count)):"
            $nonCompliant | ForEach-Object { Write-Host $_ }

            if ($env:GITHUB_STEP_SUMMARY) {
              $lines = $nonCompliant | ForEach-Object { "- $_" }
              $content = @("### clang-format non-compliant files ($($nonCompliant.Count))", "", $lines) -join "`n"
              $content | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Encoding utf8 -Append
            }

            Write-Host "Formatting issues detected. Run tools/format.ps1 -Folder <path> to fix."
            exit 1
          } else {
            Write-Host "All files formatted."
          }


  # Job responsible for configuring, building, and testing the project
  unit-tests:
    needs: format-check
    # Use the hosted Windows runner image
    runs-on: windows-latest
    # Display-friendly job name in the Actions UI
    name: Unit Tests

    # Ordered list of actions the job will perform
    steps:
      # Checkout repository contents into the runner workspace
      - name: Checkout
        uses: actions/checkout@v4

      # Ensure MSBuild toolchain components are available
      - name: Set up MSVC
        uses: microsoft/setup-msbuild@v2

      # Install Ninja build tool via Chocolatey
      - name: Install Ninja
        run: choco install ninja --no-progress --yes
        shell: pwsh
        
      - name: Set up MSVC dev environment
        uses: ilammy/msvc-dev-cmd@v1
        with:
          arch: x64

      - name: Bootstrap vcpkg
        shell: pwsh
        run: |
          $vcpkgRoot = Join-Path $env:RUNNER_TEMP "vcpkg"
          git clone https://github.com/microsoft/vcpkg.git $vcpkgRoot   # no --filter
          & "$vcpkgRoot\bootstrap-vcpkg.bat"
          "VCPKG_ROOT=$vcpkgRoot" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append

      # Generate build system files with tests enabled preset
      - name: Configure (tests enabled)
        shell: pwsh
        run: cmake --preset test

      # Compile the project using the previously generated configuration
      - name: Build (tests enabled)
        shell: pwsh
        run: cmake --build --preset test

      # Execute unit tests and show failures in the log
      - name: Run unit tests
        shell: pwsh
        run: ctest --output-on-failure --test-dir build/test

  # Job that builds with clang and enforces the coverage threshold
  coverage:
    needs:
      - unit-tests
    runs-on: windows-latest
    name: Coverage (clang)

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install LLVM (clang/coverage tools)
        run: choco install llvm --no-progress --yes
        shell: pwsh

      - name: Install Ninja
        run: choco install ninja --no-progress --yes
        shell: pwsh

      - name: Set up MSVC dev environment
        uses: ilammy/msvc-dev-cmd@v1
        with:
          arch: x64

      - name: Bootstrap vcpkg
        shell: pwsh
        run: |
          $vcpkgRoot = Join-Path $env:RUNNER_TEMP "vcpkg"
          git clone https://github.com/microsoft/vcpkg.git $vcpkgRoot   # no --filter
          & "$vcpkgRoot\bootstrap-vcpkg.bat"
          "VCPKG_ROOT=$vcpkgRoot" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append

      - name: Configure (coverage build)
        shell: pwsh
        run: cmake --preset coverage-clang

      - name: Run coverage check
        shell: pwsh
        run: cmake --build --preset coverage-clang

      - name: Summarize coverage
        if: always()
        shell: pwsh
        run: |
          $summaryPath = Join-Path "build/coverage-clang/coverage" "summary.txt"
          $htmlPath = Join-Path "build/coverage-clang/coverage/html" "index.html"
          $docsHtmlPath = Join-Path "docs/build/coverage" "index.html"
          if (Test-Path $summaryPath) {
            Write-Host "Coverage summary:"
            Get-Content $summaryPath | ForEach-Object { Write-Host $_ }
            if ($env:GITHUB_STEP_SUMMARY) {
              "# Coverage summary`n" | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Encoding utf8 -Append
              Get-Content $summaryPath | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Encoding utf8 -Append
              "" | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Encoding utf8 -Append
            }
          } else {
            Write-Host "Coverage summary not found at $summaryPath"
          }
          if (Test-Path $htmlPath) {
            Write-Host "Coverage HTML (build tree): $htmlPath"
            if ($env:GITHUB_STEP_SUMMARY) {
              "Coverage HTML (build tree): $htmlPath" | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Encoding utf8 -Append
            }
          }
          if (Test-Path $docsHtmlPath) {
            Write-Host "Coverage HTML (docs mirror): $docsHtmlPath"
            if ($env:GITHUB_STEP_SUMMARY) {
              "Coverage HTML (docs mirror): $docsHtmlPath" | Out-File -FilePath $env:GITHUB_STEP_SUMMARY -Encoding utf8 -Append
            }
          }

      - name: Upload coverage artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: coverage-report
          path: build/coverage-clang/coverage
          if-no-files-found: warn

  # Job dedicated to static analysis with clang-tidy
  clang-tidy:
    needs: format-check
    # Use the hosted Windows runner image
    runs-on: windows-latest
    # Display-friendly job name in the Actions UI
    name: Clang-Tidy Analysis

    steps:
      # Checkout repository contents into the runner workspace
      - name: Checkout
        uses: actions/checkout@v4

      # Ensure MSBuild toolchain components are available
      - name: Set up MSVC
        uses: microsoft/setup-msbuild@v2

      # Install Ninja build tool via Chocolatey
      - name: Install Ninja
        run: choco install ninja --no-progress --yes
        shell: pwsh

      # Install LLVM toolchain, providing clang-format and clang-tidy
      - name: Install LLVM (clang/clang-tidy)
        run: choco install llvm --no-progress --yes
        shell: pwsh
        
      - name: Set up MSVC dev environment
        uses: ilammy/msvc-dev-cmd@v1
        with:
          arch: x64

      - name: Bootstrap vcpkg
        shell: pwsh
        run: |
          $vcpkgRoot = Join-Path $env:RUNNER_TEMP "vcpkg"
          git clone https://github.com/microsoft/vcpkg.git $vcpkgRoot   # no --filter
          & "$vcpkgRoot\bootstrap-vcpkg.bat"
          "VCPKG_ROOT=$vcpkgRoot" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append

      # Prepare clang-tidy configuration via the corresponding CMake preset
      - name: Configure clang-tidy
        shell: pwsh
        run: cmake --preset clang-tidy

      # Run clang-tidy analysis as defined by the preset build target
      - name: Run clang-tidy
        shell: pwsh
        run: cmake --build --preset clang-tidy

  # Job that builds documentation with Doxygen and prepares it for publication
  documentation:
    # Wait for verification jobs to succeed before building docs
    needs:
      - unit-tests  # Require successful unit tests before publishing documentation
      - coverage     # Require coverage to stay enforced before docs publish
      - clang-tidy  # Require successful static analysis before publishing documentation
    # Use the hosted Windows runner image
    runs-on: windows-latest
    # Display-friendly job name in the Actions UI
    name: Documentation Build

    steps:
      # Checkout repository contents into the runner workspace
      - name: Checkout
        uses: actions/checkout@v4

      # Configure GitHub Pages build metadata for the current run
      - name: Configure Pages
        uses: actions/configure-pages@v5

      # Install Doxygen and Graphviz required for documentation generation
      - name: Install Doxygen toolchain
        run: choco install doxygen.portable graphviz --no-progress --yes
        shell: pwsh

      # Ensure the Doxygen output directory exists
      - name: Prepare documentation output directory
        shell: pwsh
        run: |
          $outputDir = Join-Path $env:GITHUB_WORKSPACE "docs/build"
          if (-not (Test-Path $outputDir)) {
            New-Item -ItemType Directory -Path $outputDir | Out-Null
          }

      # Produce HTML documentation with Doxygen and fail if warnings appear
      - name: Generate Doxygen documentation
        shell: pwsh
        run: |
          # Run Doxygen
          doxygen Doxyfile

          # Compose log path
          $log = Join-Path $PWD 'doxygen-error.log'   # ou $env:GITHUB_WORKSPACE si en CI

          # Check that the file exist
          $exists = Test-Path -LiteralPath $log

          # Check the lenght of the file. If 0 -> no error or file not found
          $size = if ($exists) { (Get-Item -LiteralPath $log).Length } else { 0 }

          if ($size -gt 0) {
            Write-Host '::error::Doxygen emitted warnings. See details below.'
            Get-Content -LiteralPath $log
            exit 1
          }

      - name: Download coverage artifact
        uses: actions/download-artifact@v4
        with:
          name: coverage-report
          path: coverage-report

      - name: Add coverage report to docs
        shell: pwsh
        run: |
          $coverageRoot = Join-Path $PWD 'coverage-report'
          if (-not (Test-Path $coverageRoot)) {
            Write-Host 'Coverage artifact not found.'; exit 1
          }

          $htmlSource = Join-Path $coverageRoot 'html'
          if (-not (Test-Path $htmlSource)) {
            $htmlSource = Get-ChildItem -Path $coverageRoot -Directory -Recurse -Filter 'html' | Select-Object -First 1
            if ($htmlSource) { $htmlSource = $htmlSource.FullName }
          }

          if (-not $htmlSource -or -not (Test-Path $htmlSource)) {
            Write-Host 'Coverage HTML directory is missing from artifact.'; exit 1
          }

          $docsCoverage = Join-Path $PWD 'docs/build/html/coverage'
          if (Test-Path $docsCoverage) {
            Remove-Item -Recurse -Force $docsCoverage
          }
          New-Item -ItemType Directory -Path $docsCoverage | Out-Null

          Copy-Item -Path (Join-Path $htmlSource '*') -Destination $docsCoverage -Recurse -Force
          Write-Host "Coverage report copied to $docsCoverage"

      # Preserve the Doxygen error log for troubleshooting
      - name: Upload Doxygen error log
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: doxygen-error-log
          path: doxygen-error.log
          if-no-files-found: warn

      # Upload the generated HTML bundle as the Pages deployment artifact
      - name: Upload Pages artifact
        uses: actions/upload-pages-artifact@v3
        with:
          # Filesystem path containing the generated HTML docs
          path: docs/build/html

  # Job that deploys the previously built documentation to GitHub Pages
  deploy-docs:
    # Wait for the documentation artifact to be ready
    needs: documentation
    # Publish from an Ubuntu runner as required by deploy-pages
    runs-on: ubuntu-latest
    # Display-friendly job name in the Actions UI
    name: Publish Documentation
    # Define the target environment and capture the published URL
    environment:
      # Use the dedicated GitHub Pages environment
      name: github-pages
      # Expose the deployed site URL from the deploy action output
      url: ${{ steps.deployment.outputs.page_url }}

    steps:
      # Deploy the uploaded artifact to GitHub Pages
      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4
